Title: Про Trunk-Based Development и CI
Date: 2022-04-22
Category: thoughts
Summary:

## TL/DR

> Trunk-Based Development is a key enabler of Continuous Integration
> and by extension Continuous Delivery. When individuals on a team
> are committing their changes to the trunk multiple times a day
> it becomes easy to satisfy the core requirement of
> Continuous Integration that all team members commit to trunk
> at least once every 24 hours. This ensures the codebase is always
> releasable on demand and helps to make Continuous Delivery a reality.

<https://trunkbaseddevelopment.com/>

## Важное свойство Continuous Integration, про которое часто забывают

Из [русской Википедии](https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%BD%D0%B0%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F):

> Непрерывная интеграция (CI, англ. Continuous Integration) — практика разработки
> программного обеспечения, которая заключается в постоянном слиянии рабочих копий
> в общую основную ветвь разработки (до нескольких раз в день)
> и выполнении частых автоматизированных сборок проекта
> для скорейшего выявления потенциальных дефектов и решения интеграционных проблем.

Многие концентрируются на второй части (*запускайте тесты в пайплайнах*),
полностью игнорируя первую (*интеграция кода каждый день*).
Но если посмотреть [англоязычную статью](https://en.wikipedia.org/wiki/Continuous_integration),
то там второй части нет в самом определении:

> In software engineering, continuous integration (CI) is the practice of merging
> all developers' working copies to a shared mainline several times a day.

Тесты появляются в списке практик, позволяющих делать частые интеграции
без ущерба для проекта, что довольно логично - если постоянно коммитишь в мастер,
то пусть хотя бы машина это проверяет.

## Про Trunk-Based Development

Загибайте пальцы, если услышали что-то знакомое:

- есть одна основная ветка, в которую коммитит вся команда;
- перед коммитом прогоняются тесты;
- если не практикуется парное программирование,
  то допускаются короткоживущие (день-два) ветки для ревью.

Они и правда очень здорово дополняют друг друга,
хотя можно делать CI и без TBD (через частый мерж в мастер).

Чем это отличается от более известных аналогов:

- [GitFlow](https://nvie.com/posts/a-successful-git-branching-model/)
  имеет виды веток под все случаи жизни - мастер, дев, хотфиксы, фичи, релизы.
  Это хорошо для очень формального процесса,
  но для небольшой команды делать ветки под что угодно становится невыносимо.
- [GithubFlow](https://guides.github.com/introduction/flow/)
  концептуально легковесный, только перед мержем код из ветки
  деплоится на продакшен и после этого мержится в мастер.
- [GitlabFlow](https://docs.gitlab.com/ee/topics/gitlab_flow.html)
  предлагает использовать ветки для фич, деплоить после мержа.
  Наверное, самый популярный вариант, хотя мало кто знает его под таким названием.

## Что дает TBD

Зачем нам может понадобиться частая интеграция, если при этом придется
полагаться на тесты, которые еще и нужно написать?
Давайте посмотрим, на плюсы и минусы,
которые на самом деле следствия частых мержей под разными углами.

### Очень быстрое развитие проекта

Что и говорить, если пушишь сразу в мастер, то быстрее уже некуда.
Если это прототип или pet-project, то по умолчанию многие даже тесты не пишут,
потому что и так сойдет.
Однако, если есть необходимость контролировать разработку
(джуниоров, например, или просто новых разработчиков),
то подход не подойдет.

### Ранний показ WIP-кода

При TBD в мастере могут оказаться незаконченные фичи.
Почему это может быть хорошо:

- естественным образом получается делать инкрементальную поставку;
- маскировка обычно делается через фича-флаги,
  которые можно использовать для легкого A/B тестирования
  или канареечных релизов.

Почему это может быть плохо:

- резко возрастают затраты на поддержку - нужно продумать сами фича-флаги,
  усложнять деплой с фича-флагами, не забыть потом их выключать;
- больше вероятность багов, если делать это неаккуратно.

### Маленькие реквесты

Если нужно коммитить в мастер почти каждый день,
то (даже с учетом короткоживущих веток) делать большие реквесты не получится.

Это дает довольно много интересных последствий:

- маленькие реквесты чаще всего понятнее больших,
  быстрее проходят ревью и проще тестируются;
- меньше искушения запихнуть трехдневную работу в один коммит,
  а значит история становится лучше;
- если реквесты большие, то приходится чаще переключаться между ними
  для доработок (и контекста в них значительно больше).
  Это работает как для автора, так и для ревьюера,
  потому что в десятый раз отсматривать реквест на 30 файлов -
  так себе удовольствие;
- маленькие реквесты вообще психологически снимают
  довольно много напряжения относительно управляемости процесса.
  Например, проще становится проводить большие рефакторинги,
  потому что любой большой процесс распадается на последовательности маленьких,
  а это классическое “разделяй и властвуй”.

К сожалению, это все означает больше работы над оформлением коммитов
и разбиением фич, чтобы они поместились в маленький реквест.

### Меньше конфликтов при мерже

Если мержить только в конце разработки,
то это позволяет довольно сильно изолировать фичи,
но и приводит к накоплению конфликтов.
И ладно бы, если речь шла только про текстовые конфликты,
которые Git умеет разруливать (хотя все равно часто приходится вмешиваться).
Хуже, когда конфликтует логика, но из-за объема изменений
это не получается отловить (в том числе и на ревью).

Частый мерж позволяет постоянно доставлять новый код другим разработчикам
(или даже в свои другие ветки, которые могут пользоваться этими изменениями),
что снижает конфликтность изменений.
Это очень важная штука, потому что большой реквест на 15 коммитов
ребейзить каждую неделю довольно больно.

## Полезные ссылки

- <https://trunkbaseddevelopment.com/>
- <https://levelup.gitconnected.com/why-are-so-many-people-against-trunk-based-development-a785d9322584>
- <https://www.branchbyabstraction.com/>

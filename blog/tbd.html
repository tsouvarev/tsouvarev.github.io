<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://classless.de/classless.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <script src="js/metrika.js" async></script>
    <title>Блог | Про Trunk-Based Development и CI</title>
</head>
<body>
    <nav>
        <ul>
            <li><a href="/">Главная</a></li>
            <li><a href="/blog">Блог</a></li>
        </ul>
    </nav>
    <article>
        <h1>Про Trunk-Based Development и CI</h1>
        <time>22 апреля 2020</time>
        <section>
            <h2>TL/DR</h2>
            <blockquote cite="https://trunkbaseddevelopment.com/">
                Trunk-Based Development is a key enabler of Continuous Integration
                and by extension Continuous Delivery. When individuals on a team
                are committing their changes to the trunk multiple times a day
                it becomes easy to satisfy the core requirement of
                Continuous Integration that all team members commit to trunk
                at least once every 24 hours. This ensures the codebase is always
                releasable on demand and helps to make Continuous Delivery a reality.
            </blockquote>
            <cite>
                <a href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com/</a>
            </cite>
        </section>

        <section>
            <h2>Важное свойство Continious Integration, про которое часто забывают</h2>
            <div>
                Из <a href="https://ru.wikipedia.org/wiki/Непрерывная_интеграция">русской Википедии</a>:
                <blockquote>
                    Непрерывная интеграция (CI, англ. Continuous Integration) — практика разработки
                    программного обеспечения, которая заключается в постоянном слиянии рабочих копий
                    в общую основную ветвь разработки (до нескольких раз в день)
                    и выполнении частых автоматизированных сборок проекта
                    для скорейшего выявления потенциальных дефектов и решения интеграционных проблем.
                </blockquote>
            </div>
            Многие концентрируются на второй части (<i>запускайте тесты в пайплайнах</i>),
            полностью игнорируя первую (<i>интеграция кода каждый день</i>).
            Но если посмотреть
            <a href="https://en.wikipedia.org/wiki/Continuous_integration">англоязычную статью</a>,
            то там второй части нет в самом определении:
            <blockquote>
                In software engineering, continuous integration (CI) is the practice of merging
                all developers' working copies to a shared mainline several times a day.
            </blockquote>

            Тесты появляются в списке практик, позволяющих делать частые интеграции
            без ущерба для проекта, что довольно логично - если постоянно коммитишь в мастер,
            то пусть хотя бы машина это проверяет.
        </section>

        <section>
        <h2>Про Trunk-Based Development</h2>

        Загибайте пальцы, если услышали что-то знакомое:
        <ul>
            <li>есть одна основная ветка, в которую коммитит вся команда;</li>
            <li>перед коммитом прогоняются тесты;</li>
            <li>если не практикуется парное программирование,
                то допускаются короткоживущие (день-два) ветки для ревью.</li>
            </ul>
            Они и правда очень здорово дополняют друг друга,
            хотя можно делать CI и без TBD (через частый мерж в мастер).
            <br>
            Чем это отличается от более известных аналогов:
            <ul>
                <li>
                    <a href="https://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a>
                    имеет виды веток под все случаи жизни - мастер, дев, хотфиксы, фичи, релизы.
                    Это хорошо для очень формального процесса,
                    но для небольшой команды делать ветки под что угодно становится невыносимо.
                </li>
                <li>
                    <a href="https://guides.github.com/introduction/flow/">GithubFlow</a>
                    концептуально легковесный, только перед мержем код из ветки
                    деплоится на продакшен и после этого мержится в мастер.
                </li>
                <li>
                    <a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html">GitlabFlow</a>
                    предлагает использовать ветки для фич, деплоить после мержа.
                    Наверное, самый популярный вариант, хотя мало кто знает его под таким названием.
                </li>
            </ul>
        </section>

        <section>
            <h2>Что дает TBD</h2>

            Зачем нам может понадобиться частая интеграция, если при этом придется
            полагаться на тесты, которые еще и нужно написать?
            Давайте посмотрим, на плюсы и минусы,
            которые на самом деле следствия частых мержей под разными углами.

            <section>
                <h3>Очень быстрое развитие проекта</h3>

                Что и говорить, если пушишь сразу в мастер, то быстрее уже некуда.
                Если это прототип или pet-project, то по умолчанию многие даже тесты не пишут,
                потому что и так сойдет.
                Однако, если есть необходимость контролировать разработку
                (джуниоров, например, или просто новых разработчиков),
                то подход не подойдет.
            </section>

            <section>
                <h3>Ранний показ WIP-кода</h3>

                При TBD в мастере могут оказаться незаконченные фичи.

                Почему это может быть хорошо:
                <ul>
                    <li>естественным образом получается делать инкрементальную поставку;</li>
                    <li>маскировка обычно делается через фича-флаги,
                        которые можно использовать для легкого A/B тестирования
                        или канареечных релизов.</li>
                </ul>

                Почему это может быть плохо:
                <ul>
                    <li>резко возрастают затраты на поддержку -
                        нужно продумать сами фича-флаги, усложнять деплой с фича-флагами,
                        не забыть потом их выключать;</li>
                    <li>больше вероятность багов, если делать это неаккуратно.</li>
                </ul>
            </section>

            <section>
                <h3>Маленькие реквесты</h3>

                Если нужно коммитить в мастер почти каждый день,
                то (даже с учетом короткоживущих веток) делать большие реквесты не получится.

                Это дает довольно много интересных последствий:
                <ul>
                    <li>маленькие реквесты чаще всего понятнее больших,
                        быстрее проходят ревью и проще тестируются;</li>
                    <li>меньше искушения запихнуть трехдневную работу в один коммит,
                        а значит история становится лучше;</li>
                    <li>если реквесты большие, то приходится чаще переключаться между ними
                        для доработок (и контекста в них значительно больше).
                        Это работает как для автора, так и для ревьюера,
                        потому что в десятый раз отсматривать реквест на 30 файлов -
                        так себе удовольствие;</li>
                    <li>маленькие реквесты вообще психологически снимают
                        довольно много напряжения относительно управляемости процесса.
                        Например, проще становится проводить большие рефакторинги,
                        потому что любой большой процесс распадается на последовательности маленьких,
                        а это классическое “разделяй и властвуй”.</li>
                </ul>

                К сожалению, это все означает больше работы над оформлением коммитов
                и разбиением фич, чтобы они поместились в маленький реквест.
            </section>

            <section>
                <h3>Меньше конфликтов при мерже</h3>

                Если мержить только в конце разработки,
                то это позволяет довольно сильно изолировать фичи,
                но и приводит к накоплению конфликтов.
                И ладно бы, если речь шла только про текстовые конфликты,
                которые Git умеет разруливать (хотя все равно часто приходится вмешиваться).
                Хуже, когда конфликтует логика, но из-за объема изменений
                это не получается отловить (в том числе и на ревью).

                Частый мерж позволяет постоянно доставлять новый код другим разработчикам
                (или даже в свои другие ветки, которые могут пользоваться этими изменениями),
                что снижает конфликтность изменений.
                Это очень важная штука, потому что большой реквест на 15 коммитов
                ребейзить каждую неделю довольно больно.
            </section>
        </section>

        <section>
            <h2>Полезные ссылки</h2>
            <ul>
                <li>
                    <a href="https://trunkbaseddevelopment.com/">
                        https://trunkbaseddevelopment.com/</a>
                </li>
                <li>
                    <a href="https://levelup.gitconnected.com/why-are-so-many-people-against-trunk-based-development-a785d9322584">
                        https://levelup.gitconnected.com/why-are-so-many-people-against-trunk-based-development-a785d9322584
                    </a>
                </li>
                <li>
                    <a href="https://www.branchbyabstraction.com/">
                        https://www.branchbyabstraction.com/</a>
                </li>
            </ul>
        </section>
    </article>
</body>
</html>
